@inject IDialogService DialogService
@inject ISnackbar Snackbar

<MudStack Row="false" Class="wh100" data-test-id="classExplorer">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <MudText>@Class.Name</MudText>
        <div>
            <!-- Always visible buttons for testing -->
            <MudIconButton Icon="@Icons.Material.Filled.Add" Size="Size.Small" OnClick="ShowCreateMethodDialog" data-test-id="create-method" Title="Add method" Style="opacity: 0.3;" />
            @if (SelectedTreeItem?.Type == TreeItemType.Method)
            {
                <MudIconButton Icon="@Icons.Material.Filled.DriveFileRenameOutline" Size="Size.Small" OnClick="() => ShowRenameMethodDialog(SelectedTreeItem!)" data-test-id="rename-method" Title="Rename method" Style="opacity: 0.3;" />
                <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" OnClick="() => DeleteMethod(SelectedTreeItem!)" data-test-id="delete-method" Title="Delete method" Style="opacity: 0.3;" />
            }
        </div>
    </div>

    <MudTreeView T="TreeItem" Items="Items" SelectedValueChanged="OnSelectedItemChanged" Dense="true" Class="w100">
        <ItemTemplate>
            @if (context.Value == null)
            { }
            else if (context.Value == CurrentlyEditingItem)
            {
                <MudTreeViewItem @bind-Expanded="@context.Expanded" Items="@context.Children" Value="@context.Value" Text="@context.Text" EndTextTypo="@Typo.caption">
                    <BodyContent Context="Item">
                        <MudTextField T="string" Typo="Typo.caption" @bind-Value="Text" Variant="Variant.Text" OnKeyUp="OnEditTextKeyUp" AutoFocus="true"></MudTextField>
                    </BodyContent>
                </MudTreeViewItem>
            }
            else if (context.Value.Type == TreeItemType.MethodsFolder || context.Value.Type == TreeItemType.PropertiesFolder)
            {
                <MudTreeViewItem @bind-Expanded="@context.Expanded" Items="@context.Children" Value="@context.Value" Text="@context.Value!.Name" EndTextTypo="@Typo.caption">
                    <BodyContent Context="Item">
                        <div style="display: grid; grid-template-columns: 1fr auto; align-items: center; width: 100%" @onmouseover="() => Hovered = Item.Value" @onmouseout="() => Hovered = null" data-test-id="@context.Value.Type">
                            <MudText Style="justify-self: start;">@Item.Text</MudText>
                            <div style="@($"justify-self: end; visibility: {(Hovered == Item.Value ? "visible" : "hidden")}")">
                                @if (context.Value.Type == TreeItemType.MethodsFolder)
                                {
                                    <MudIconButton Icon="@Icons.Material.Filled.Add" Size="Size.Medium" Color="Color.Inherit" OnClick="ShowCreateMethodDialog" />
                                }
                                else
                                {
                                    <MudIconButton Icon="@Icons.Material.Filled.Add" Size="Size.Medium" Color="Color.Inherit" OnClick="ShowNewProperty" />
                                }
                            </div>
                        </div>
                    </BodyContent>
                </MudTreeViewItem>
            }
            else if (context.Value.Type == TreeItemType.Method)
            {
                <MudTreeViewItem @bind-Expanded="@context.Expanded" Value="@context.Value" EndTextTypo="@Typo.caption" data-test-id="Method" data-test-method="@context.Value!.Name">
                    <Content>
                        <div style="display: grid; grid-template-columns: 1fr auto; align-items: center; width: 100%" @onmouseover="() => Hovered = context.Value" @onmouseout="() => Hovered = null">
                            <MudText Typo="Typo.caption">@context.Value!.Method!.ReturnType.FriendlyName @context.Value.Name (@string.Join(',', context.Value.Method!.Parameters.Select(x => $"{x.ParameterType.FriendlyName} {x.Name}")))</MudText>
                            <div style="@($"justify-self: end; visibility: {(Hovered == context.Value ? "visible" : "hidden")}")">
                                <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Medium" Color="Color.Inherit" OnClick="() => ShowMethodEdit(context.Value!)" />
                                <MudIconButton Icon="@Icons.Material.Filled.DriveFileRenameOutline" Size="Size.Medium" Color="Color.Inherit" OnClick="() => ShowRenameMethodDialog(context.Value!)" />
                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Medium" Color="Color.Inherit" OnClick="() => DeleteMethod(context.Value!)" />
                            </div>
                        </div>
                    </Content>
                </MudTreeViewItem>
            }
            else if (context.Value.Type == TreeItemType.Property && context.Value.Property != null)
            {
                <MudTreeViewItem @bind-Expanded="@context.Expanded" Value="@context.Value" Text="@context.Value.Name" EndTextTypo="@Typo.caption">
                    <BodyContent Context="Item">
                        <div style="display: grid; grid-template-columns: 1fr auto; align-items: center; width: 100%" @onmouseover="() => Hovered = Item.Value" @onmouseout="() => Hovered = null" data-test-id="Property">
                            <MudText Typo="Typo.caption" Style="justify-self: start;">@Item.Value!.Property!.PropertyType.FriendlyName @Item.Value!.Name</MudText>
                            <div style="@($"justify-self: end; visibility: {(Hovered == Item.Value ? "visible" : "hidden")}")">
                                <MudIconButton Icon="@Icons.Material.Filled.ShapeLine" Size="Size.Medium" Color="Color.Inherit" OnClick="() => ShowPropertyTypeEdit(Item.Value!)" />
                                <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Medium" Color="Color.Inherit" OnClick="() => ShowRenameMenu(Item.Value!)" />
                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Medium" Color="Color.Inherit" />
                            </div>
                        </div>
                    </BodyContent>
                </MudTreeViewItem>
            }
        </ItemTemplate>
    </MudTreeView>
</MudStack>


@code {

    private enum TreeItemType
    {
        PropertiesFolder,
        Property,
        MethodsFolder,
        Method
    }
    private record class TreeItem(TreeItemType Type, NodeDev.Core.Class.NodeClassMethod? Method, NodeDev.Core.Class.NodeClassProperty? Property)
    {
        public string Name { get; set; } = "";
        public bool IsExpanded { get; set; } = true;
    }

    [Parameter]
    public NodeDev.Core.Class.NodeClass Class { get; set; } = null!;

    [Parameter]
    public NodeDev.Core.Class.NodeClassMethod? SelectedMethod { get; set; }

    [Parameter]
    public EventCallback<NodeDev.Core.Class.NodeClassMethod?> SelectedMethodChanged { get; set; }

    private TreeItem? SelectedTreeItem;

    private List<TreeItemData<TreeItem>> Items { get; } = [];

    private TreeItem? Hovered = null;

    private TreeItem? CurrentlyEditingItem = null;
    private string? Text = null;
    public bool IsNew = false;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        TreeItemData<TreeItem> methodsFolder;
        TreeItemData<TreeItem> propertiesFolder;

        Items.Add(methodsFolder = new()
            {
                Value = new(TreeItemType.MethodsFolder, null, null)
                {
                    Name = "Methods"
                },
                Expanded = true,
                Children = []
            });

        Items.Add(propertiesFolder = new()
            {
                Value = new(TreeItemType.PropertiesFolder, null, null)
                {
                    Name = "Properties"
                },
                Expanded = true,
                Children = []
            });

        foreach (var method in Class.Methods)
        {
            methodsFolder.Children.Add(new()
                {
                    Value = new(TreeItemType.Method, method, null)
                    {
                        Name = method.Name
                    }
                });
        }

        foreach (var property in Class.Properties)
        {
            propertiesFolder.Children.Add(new()
                {
                    Value = new(TreeItemType.Property, null, property)
                    {
                        Name = property.Name
                    }
                });
        }
    }

    private void ShowAddMethodMenu()
    {
        var newItem = new TreeItemData<TreeItem>()
            {
                Value = new TreeItem(TreeItemType.Method, null, null)
                {
                    Name = "NewMethod"
                }
            };
        Items.First(x => x.Value?.Type == TreeItemType.MethodsFolder).Children!.Add(newItem);

        CurrentlyEditingItem = newItem.Value;
        IsNew = true;
        Text = CurrentlyEditingItem.Name;

    }

    private void ShowNewProperty()
    {
        var newItem = new TreeItemData<TreeItem>()
            {
                Value = new(TreeItemType.Property, null, null)
                {
                    Name = "NewProperty"
                }
            };
        Items.First(x => x.Value!.Type == TreeItemType.PropertiesFolder).Children!.Add(newItem);

        CurrentlyEditingItem = newItem.Value;
        IsNew = true;
        Text = CurrentlyEditingItem.Name;

    }

    private async Task ShowCreateMethodDialog()
    {
        var result = await DialogService.Show<CreateMethodDialog>("Create New Method", new()
        {
            [nameof(CreateMethodDialog.Class)] = Class
        }, new DialogOptions()
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        }).Result;

        if (result != null && !result.Canceled && result.Data is NodeDev.Core.Class.NodeClassMethod method)
        {
            Items.First(x => x.Value!.Type == TreeItemType.MethodsFolder).Children!.Add(new()
            {
                Value = new(TreeItemType.Method, method, null)
                {
                    Name = method.Name
                }
            });
            Snackbar.Add($"Method '{method.Name}' created successfully", Severity.Success);
            StateHasChanged();
        }
    }

    private async Task ShowRenameMethodDialog(TreeItem item)
    {
        if (item.Method == null) return;

        var dialogReference = DialogService.Show<RenameDialog>("Rename Method", new()
        {
            [nameof(RenameDialog.CurrentName)] = item.Method.Name,
            [nameof(RenameDialog.Label)] = "Method Name",
            [nameof(RenameDialog.IsMethod)] = true
        }, new DialogOptions()
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        });
        
        var result = await dialogReference.Result;

        if (result != null && !result.Canceled && result.Data is string newName)
        {
            var oldName = item.Method.Name;
            item.Method.Rename(newName);
            item.Name = newName; // Update the tree item name for display
            Snackbar.Add($"Method renamed from '{oldName}' to '{newName}'", Severity.Success);
            StateHasChanged();
        }
    }

    private async Task DeleteMethod(TreeItem item)
    {
        if (item.Method == null) return;

        var confirm = await DialogService.ShowMessageBox(
            "Delete Method",
            $"Are you sure you want to delete method '{item.Method.Name}'?",
            yesText: "Delete", cancelText: "Cancel",
            options: new DialogOptions() { MaxWidth = MaxWidth.Small }
        );

        if (confirm == true)
        {
            // Note: There's no public API to remove methods, so we just remove from UI
            Items.First(x => x.Value!.Type == TreeItemType.MethodsFolder).Children!.RemoveAll(x => x.Value?.Method == item.Method);
            Snackbar.Add($"Method '{item.Method.Name}' removed from view (Note: No API to actually delete)", Severity.Warning);
            StateHasChanged();
        }
    }


    private void ShowRenameMenu(TreeItem item)
    {
        if (item == null)
            return;

        Text = item.Name;
        CurrentlyEditingItem = item;
        IsNew = false;
    }

    private async Task ShowPropertyTypeEdit(TreeItem item)
    {
        var result = await DialogService.Show<TypeSelectorDialog>("", new()
            {
                [nameof(TypeSelectorDialog.TypeFactory)] = Class.TypeFactory
            }, new DialogOptions()
            {
                FullScreen = true,
                FullWidth = true
            }).Result;

        NodeDev.Core.Types.TypeBase typeBase;
        if (result?.Data is Type type)
            typeBase = Class.TypeFactory.Get(type, null);
        else if (result?.Data is NodeDev.Core.Types.TypeBase t)
            typeBase = t;
        else
            return;

        item.Property!.ChangeType(typeBase);
    }

    private async Task ShowMethodEdit(TreeItem item)
    {
        var result = await DialogService.Show<EditMethodMenu>("", new()
            {
                [nameof(EditMethodMenu.Method)] = item.Method
            }, new DialogOptions()
            {
                FullScreen = false,
                FullWidth = true,
                MaxWidth = MaxWidth.Large
            }).Result;
    }

    private void OnEditTextKeyUp(KeyboardEventArgs args)
    {
        if (args.Key != "Enter" || string.IsNullOrWhiteSpace(Text) || CurrentlyEditingItem == null)
            return;

        if (IsNew)
        {
            if (CurrentlyEditingItem!.Type == TreeItemType.Method)
            {
                var method = new Core.Class.NodeClassMethod(Class, Text, Class.TypeFactory.Get(typeof(void), null));
                Class.AddMethod(method, createEntryAndReturn: true);

                Items.First(x => x.Value!.Type == TreeItemType.MethodsFolder).Children!.RemoveAll(x => x.Value == CurrentlyEditingItem);
                Items.First(x => x.Value!.Type == TreeItemType.MethodsFolder).Children!.Add(new()
                    {
                        Value = new(TreeItemType.Method, method, null)
                        {
                            Name = method.Name
                        }
                    });
            }
            else if (CurrentlyEditingItem.Type == TreeItemType.Property)
            {
                var property = new Core.Class.NodeClassProperty(Class, Text, Class.TypeFactory.Get<double>());
                Class.Properties.Add(property);

                Items.First(x => x.Value!.Type == TreeItemType.PropertiesFolder).Children!.RemoveAll(x => x.Value == CurrentlyEditingItem);
                Items.First(x => x.Value!.Type == TreeItemType.PropertiesFolder).Children!.Add(new()
                    {
                        Value = new(TreeItemType.Property, null, property)
                        {
                            Name = property.Name
                        }
                    });
            }
        }
        else if (CurrentlyEditingItem.Method != null)
        {
            CurrentlyEditingItem.Method.Rename(Text);
            CurrentlyEditingItem.Name = Text;
        }
        else if (CurrentlyEditingItem.Property != null)
        {
            CurrentlyEditingItem.Property.Rename(Text);
            CurrentlyEditingItem.Name = Text;
        }

        CurrentlyEditingItem = null;
        Text = null;
    }

    private void OnSelectedItemChanged(TreeItem? tree)
    {
        if (CurrentlyEditingItem != null)
        {
            // remove the textbox
            if (IsNew)
                Items.First().Children!.RemoveAll(x => x.Value == CurrentlyEditingItem);

            CurrentlyEditingItem = null;
            Text = null;
        }

        SelectedTreeItem = tree;

        if (tree?.Type == TreeItemType.Method)
        {
            SelectedMethod = tree.Method;
            _ = SelectedMethodChanged.InvokeAsync(SelectedMethod);
        }
        else
        {
            SelectedMethod = null;
            _ = SelectedMethodChanged.InvokeAsync(SelectedMethod);
        }

    }

}