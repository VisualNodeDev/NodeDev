<MudStack Row="false" Class="wh100">
	<MudText>@Class.Name</MudText>

	<MudTreeView T="TreeItem" Items="Items" SelectedValueChanged="OnSelectedItemChanged" Class="flex-1">
		<ItemTemplate>

			@if (context == CurrentlyEditingItem)
			{
				<MudTextField T="string" @bind-Value="Text" @bind-Value:after="MethodNameChanged" Variant="Variant.Text" OnKeyUp="OnEditTextKeyUp"></MudTextField>
			}
			else if (context.Type == TreeItemType.Folder)
			{
				<MudMenu ActivationEvent="@MouseEvent.RightClick">
					<ActivatorContent>
						<MudTreeViewItem @bind-Expanded="@context.IsExpanded" Items="@context.Children" Value="@context" Text="@context.Name" EndTextTypo="@Typo.caption" />
					</ActivatorContent>
					<ChildContent>
						<MudMenuItem OnClick="ShowAddMethodMenu">Create new method</MudMenuItem>
					</ChildContent>
				</MudMenu>
			}
			else if (context.Type == TreeItemType.Method)
			{
				<MudTreeViewItem @bind-Expanded="@context.IsExpanded" Value="@context" Text="@context.Name" EndTextTypo="@Typo.caption" />
			}
		</ItemTemplate>
	</MudTreeView>
</MudStack>

@code {

	private enum TreeItemType
	{
		Folder,
		Method
	}
	private record class TreeItem(string Name, HashSet<TreeItem> Children, TreeItemType Type, NodeDev.Core.Class.NodeClassMethod? Method)
	{
		public bool IsExpanded { get; set; } = true;
	}

	[Parameter]
	public NodeDev.Core.Class.NodeClass Class { get; set; } = null!;

	[Parameter]
	public NodeDev.Core.Class.NodeClassMethod? SelectedMethod { get; set; }

	[Parameter]
	public EventCallback<NodeDev.Core.Class.NodeClassMethod?> SelectedMethodChanged { get; set; }


	private HashSet<TreeItem> Items { get; } = new();

	private TreeItem? CurrentlyEditingItem = null;
	private string? Text = null;
	public bool IsNew = false;

	protected override void OnInitialized()
	{
		base.OnInitialized();

		Items.Add(new("Methods", new(), TreeItemType.Folder, null));

		foreach (var method in Class.Methods)
			Items.First().Children.Add(new(method.Name, new(), TreeItemType.Method, method));
	}

	private void ShowAddMethodMenu()
	{
		CurrentlyEditingItem = new TreeItem("NewMethod", new(), TreeItemType.Method, null);
		IsNew = true;
		Text = CurrentlyEditingItem.Name;

		Items.First().Children.Add(CurrentlyEditingItem);
	}

	private void MethodNameChanged()
	{

	}

	private void OnEditTextKeyUp(KeyboardEventArgs args)
	{
		if (args.Key != "Enter" || string.IsNullOrWhiteSpace(Text) || CurrentlyEditingItem == null)
			return;

		if (IsNew)
		{
			var method = new Core.Class.NodeClassMethod(Class, Text, Core.Types.TypeFactory.Get(typeof(void)), new Core.Graph());
			method.Graph.AddNode(new Core.Nodes.Flow.EntryNode(method.Graph));
			method.Graph.AddNode(new Core.Nodes.Flow.ReturnNode(method.Graph));
			Class.Methods.Add(method);

			Items.First().Children.Remove(CurrentlyEditingItem);
			Items.First().Children.Add(new(Text, new(), TreeItemType.Method, method));
		}
		else if(CurrentlyEditingItem.Method != null)
			CurrentlyEditingItem.Method.Rename(Text);


		CurrentlyEditingItem = null;
		Text = null;
	}

	private void OnSelectedItemChanged(TreeItem? tree)
	{
		if (tree?.Type == TreeItemType.Method)
		{
			SelectedMethod = tree.Method;
			_ = SelectedMethodChanged.InvokeAsync(SelectedMethod);
		}
		else
		{
			SelectedMethod = null;
			_ = SelectedMethodChanged.InvokeAsync(SelectedMethod);
		}

	}

}