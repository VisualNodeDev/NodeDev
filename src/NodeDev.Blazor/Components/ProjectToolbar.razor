@using Microsoft.AspNetCore.Components.Forms
@using NodeDev.Blazor.Services
@using NodeDev.Core
@implements IDisposable
@inject ProjectService ProjectService
@inject ISnackbar Snackbar
@inject AppOptionsContainer AppOptionsContainer
@inject IDialogService DialogService


<MudButton OnClick="Open" Class="ml-3" Disabled=@Project.IsLiveDebuggingEnabled data-test-id="open-project">Open</MudButton>
<MudButton OnClick="NewProject" Class="ml-3" Disabled=@Project.IsLiveDebuggingEnabled data-test-id="newProject">New Project</MudButton>
<MudButton OnClick="Save" Class="ml-3" data-test-id="save">Save</MudButton>
<MudButton OnClick="SaveAs" Class="ml-3" data-test-id="saveAs">Save As</MudButton>
<MudButton OnClick="Build" Class="ml-3" data-test-id="build-project">Build</MudButton>

@if (Project.IsHardDebugging)
{
    <MudIconButton Icon="@Icons.Material.Filled.Stop" Class="ml-3" OnClick="StopDebugging" data-test-id="stop-debug" Title="Stop Debugging" Color="Color.Error" />
    <MudIconButton Icon="@Icons.Material.Filled.Pause" Class="ml-3" OnClick="PauseDebugging" data-test-id="pause-debug" Title="Pause" Disabled="true" />
    <MudIconButton Icon="@Icons.Material.Filled.PlayArrow" Class="ml-3" OnClick="ResumeDebugging" data-test-id="resume-debug" Title="Continue" Disabled="@(!Project.IsPausedAtBreakpoint)" Color="@(Project.IsPausedAtBreakpoint ? Color.Success : Color.Default)" />
    @if (Project.IsPausedAtBreakpoint && Project.CurrentBreakpoint != null)
    {
        <MudText Color="Color.Error" Class="ml-2 align-self-center" data-test-id="breakpoint-status-text" Typo="Typo.body2">
            ⏸ PAUSED at breakpoint: @Project.CurrentBreakpoint.NodeName
        </MudText>
    }
    else
    {
        <MudText Color="Color.Warning" Class="ml-2 align-self-center" data-test-id="debug-status-text" Typo="Typo.body2">Debugging (PID: @Project.DebuggedProcessId)</MudText>
    }
}
else
{
    <MudIconButton Icon="@Icons.Material.Filled.PlayArrow" Class="ml-3" OnClick="Run" data-test-id="run-project" Title="Run" />
    <MudIconButton Icon="@Icons.Material.Filled.BugReport" Class="ml-3" OnClick="RunWithDebug" data-test-id="run-with-debug" Title="Run with Debug" Color="Color.Info" />
}

<MudButton OnClick="Export" Class="ml-3" data-test-id="export-project">Export</MudButton>
<MudButton OnClick="Add" Class="ml-3">Add node</MudButton>
<MudButton OnClick="SwitchLiveDebugging">@(Project.IsLiveDebuggingEnabled ? "Stop Live Debugging" : "Start Live Debugging")</MudButton>
<MudButton OnClick="ToggleBreakpoint" Class="ml-3" data-test-id="toggle-breakpoint" Title="Toggle Breakpoint (F9)">
    <MudIcon Icon="@Icons.Material.Filled.FiberManualRecord" Color="Color.Error" Size="Size.Small" />
</MudButton>
<MudSpacer />
<MudButton OnClick="OpenOptionsDialogAsync" Class="ml-3" data-test-id="options">Options</MudButton>
<MudIconButton Icon="@Icons.Material.Filled.MoreVert" Color="Color.Inherit" Edge="Edge.End" />


@code {

    [CascadingParameter]
    public NodeDev.Blazor.Index? IndexPage { get; set; }

    private Project Project => ProjectService.Project;

    private DialogOptions DialogOptions => new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true };

    private IDisposable? HardDebugStateSubscription;
    private IDisposable? CurrentBreakpointSubscription;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        
        // Subscribe to hard debug state changes to refresh UI
        HardDebugStateSubscription = Project.HardDebugStateChanged.Subscribe(_ =>
        {
            InvokeAsync(StateHasChanged);
        });
        
        // Subscribe to current breakpoint changes to refresh UI
        CurrentBreakpointSubscription = Project.CurrentBreakpointChanged.Subscribe(breakpoint =>
        {
            Console.WriteLine($"[ProjectToolbar] CurrentBreakpoint changed: {(breakpoint != null ? $"{breakpoint.NodeName}" : "null")}");
            InvokeAsync(StateHasChanged);
        });
    }

    public void Dispose()
    {
        HardDebugStateSubscription?.Dispose();
        CurrentBreakpointSubscription?.Dispose();
    }

    private Task Open()
    {
        return DialogService.ShowAsync<OpenProjectDialog>("Open Project", DialogOptions);
    }

    private Task Save()
    {
        if (string.IsNullOrWhiteSpace(Project.Settings.ProjectName))
        {
            return SaveAs();
        }

        try
        {
            ProjectService.SaveProjectToFile();
            Snackbar.Add("Project saved", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add(ex.Message, Severity.Error);
        }
        
		return Task.CompletedTask;
    }

	private Task SaveAs()
	{
        return DialogService.ShowAsync<SaveAsProjectDialog>("Save As Project", DialogOptions);
	}

    private void NewProject()
    {
        ProjectService.ChangeProject(Core.Project.CreateNewDefaultProject());
    }

    private void Add()
    {
        //GraphCanvas?.ShowAddNode();
    }

    public void Run()
    {
        new Thread(() =>
        {
            Project.Run(Project.IsLiveDebuggingEnabled ? Core.BuildOptions.Debug : Core.BuildOptions.Release);
        }).Start();
    }

    public void RunWithDebug()
    {
        new Thread(() =>
        {
            try
            {
                Project.RunWithDebug(Core.BuildOptions.Debug);
            }
            catch (Exception ex)
            {
                // Show error dialog on UI thread
                InvokeAsync(async () =>
                {
                    await DialogService.ShowMessageBox(
                        "Debug Attachment Failed",
                        ex.Message,
                        yesText: "OK");
                });
            }
        }).Start();
    }

    public void StopDebugging()
    {
        try
        {
            Project.StopDebugging();
            Snackbar.Add("Debugging stopped", Severity.Info);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to stop debugging: {ex.Message}", Severity.Error);
        }
    }

    public void PauseDebugging()
    {
        // Placeholder for future implementation
        Snackbar.Add("Pause functionality coming soon", Severity.Info);
    }

    public void ResumeDebugging()
    {
        try
        {
            Project.ContinueExecution();
            Snackbar.Add("Execution resumed", Severity.Success);
        }
        catch (InvalidOperationException ex)
        {
            Snackbar.Add($"Cannot resume: {ex.Message}", Severity.Error);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to resume: {ex.Message}", Severity.Error);
        }
    }

    public void Build()
    {
        try
        {
            Project.Build(Core.BuildOptions.Debug);
            Snackbar.Add("Project built successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Build failed: {ex.Message}", Severity.Error);
        }
    }

    public void Export()
    {
        try
        {
            // Export functionality - for now, just show a message
            Snackbar.Add("Export functionality not yet implemented", Severity.Info);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Export failed: {ex.Message}", Severity.Error);
        }
    }

    private void SwitchLiveDebugging()
    {
        if (Project.IsLiveDebuggingEnabled)
            Project.StopLiveDebugging();
        else
            Project.StartLiveDebugging();
    }

    private void ToggleBreakpoint()
    {
        IndexPage?.ToggleBreakpointOnSelectedNode();
    }

    private Task OpenOptionsDialogAsync()
    {
        return DialogService.ShowAsync<OptionsDialog>("Options", DialogOptions);
    }
}
