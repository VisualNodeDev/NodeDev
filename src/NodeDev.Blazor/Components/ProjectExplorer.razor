@inject IDialogService DialogService
@inject ISnackbar Snackbar

<MudStack Row="false" Class="wh100">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <MudText>Project</MudText>
        <div>
            <MudIconButton Icon="@Icons.Material.Filled.Add" Size="Size.Small" OnClick="ShowCreateClassDialog" data-test-id="create-class" Title="Create new class" />
            @if (Selected?.Type == TreeItemType.Class)
            {
                <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" OnClick="() => ShowRenameClassDialog(Selected!)" data-test-id="rename-class" Title="Rename class" />
                <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" OnClick="() => DeleteClass(Selected!)" data-test-id="delete-class" Title="Delete class" />
            }
        </div>
    </div>

    <MudTreeView T="TreeItem" Items="Items" @bind-SelectedValue="Selected" @bind-SelectedValue:after="OnSelectedItemChanged" Class="flex-1" data-test-id="projectExplorer">
        <ItemTemplate>
            @if (context.Value == null)
            { }
            else if (context.Value.Type == TreeItemType.Folder)
            {
                <MudTreeViewItem @bind-Expanded="@context.Expanded" Items="@context.Children" Value="@context.Value" Text="@context.Value.Name" EndTextTypo="@Typo.caption" data-test-id="projectExplorerMethod" />
            }
            else if (context.Value.Type == TreeItemType.Class)
            {
                <MudTreeViewItem @bind-Expanded="@context.Expanded" Value="@context.Value" Text="@context.Value.Name" EndTextTypo="@Typo.caption" data-test-id="projectExplorerClass" />
            }
        </ItemTemplate>
    </MudTreeView>
</MudStack>

@code {

    private enum TreeItemType
    {
        Folder,
        Class
    }

    private record class TreeItem(string Name, TreeItemType Type, NodeDev.Core.Class.NodeClass? Class)
    {
        public bool IsExpanded { get; set; } = true;
    }

    [Parameter]
    public NodeDev.Core.Project Project { get; set; } = null!;

    [Parameter]
    public NodeDev.Core.Class.NodeClass? SelectedClass { get; set; }

    [Parameter]
    public EventCallback<NodeDev.Core.Class.NodeClass?> SelectedClassChanged { get; set; }

    private TreeItem? Selected = null;
    private TreeItem? HoveredClass = null;

    private List<TreeItemData<TreeItem>> Items { get; } = new();

    private void OnSelectedItemChanged()
    {
        if (Selected?.Type == TreeItemType.Class)
        {
            SelectedClass = Selected.Class;
            _ = SelectedClassChanged.InvokeAsync(SelectedClass);
        }
        else
        {
            SelectedClass = null;
            _ = SelectedClassChanged.InvokeAsync(SelectedClass);
        }
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();

        foreach (var nodeClass in Project.Classes)
            AddClass(nodeClass);
    }

    private void AddClass(NodeDev.Core.Class.NodeClass nodeClass)
    {
        // find the folder that already exists in the tree
        var folders = nodeClass.Namespace.Split('.');
        TreeItemData<TreeItem>? folder = null;
        for (int i = 0; i < folders.Length; ++i)
        {
            var parent = folder?.Children ?? Items;
            folder = parent.FirstOrDefault(x => x.Value?.Name == folders[i] && x.Value?.Type == TreeItemType.Folder);
            if (folder == null)
            {
                folder = new TreeItemData<TreeItem>()
                    {
                        Value = new(folders[i], TreeItemType.Folder, null),
                        Children = [],
                        Expanded = true
                    };
                parent.Add(folder);
            }
        }

        if (folder?.Children == null)
            throw new Exception("Call cannot have no namespace ??");

        folder.Children.Add(new()
            {
                Value = new(nodeClass.Name, TreeItemType.Class, nodeClass)
            });
    }

    private async Task ShowCreateClassDialog()
    {
        var result = await DialogService.Show<CreateClassDialog>("Create New Class", new()
        {
            [nameof(CreateClassDialog.Project)] = Project
        }, new DialogOptions()
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        }).Result;

        if (result != null && !result.Canceled && result.Data is NodeDev.Core.Class.NodeClass newClass)
        {
            AddClass(newClass);
            Snackbar.Add($"Class '{newClass.Name}' created successfully", Severity.Success);
            StateHasChanged();
        }
    }

    private async Task ShowRenameClassDialog(TreeItem item)
    {
        if (item.Class == null) return;

        var result = await DialogService.Show<RenameDialog>("Rename Class", new()
        {
            [nameof(RenameDialog.CurrentName)] = item.Class.Name,
            [nameof(RenameDialog.Label)] = "Class Name",
            [nameof(RenameDialog.IsMethod)] = false
        }, new DialogOptions()
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        }).Result;

        if (result != null && !result.Canceled && result.Data is string newName)
        {
            var oldName = item.Class.Name;
            item.Class.Name = newName; // Name is a settable property
            Snackbar.Add($"Class renamed from '{oldName}' to '{newName}'", Severity.Success);
            StateHasChanged();
        }
    }

    private async Task DeleteClass(TreeItem item)
    {
        if (item.Class == null) return;

        var confirm = await DialogService.ShowMessageBox(
            "Delete Class",
            $"Are you sure you want to delete class '{item.Class.Name}'?",
            yesText: "Delete", cancelText: "Cancel",
            options: new DialogOptions() { MaxWidth = MaxWidth.Small }
        );

        if (confirm == true)
        {
            // Note: There's no public API to remove classes, so we just remove from UI
            // Remove from tree
            TreeItemData<TreeItem>? Remove(List<TreeItemData<TreeItem>> items)
            {
                foreach (var i in items.ToList())
                {
                    if (i.Value == item)
                    {
                        items.Remove(i);
                        return i;
                    }
                    if (i.Children != null)
                    {
                        var found = Remove(i.Children);
                        if (found != null)
                            return found;
                    }
                }
                return null;
            }

            Remove(Items);
            Snackbar.Add($"Class '{item.Class.Name}' removed from view (Note: No API to actually delete)", Severity.Warning);
            StateHasChanged();
        }
    }

}
